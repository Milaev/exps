function say () {
  console.log(this.nickname + ' говорит: ' + this.greeting + '.');

  this.goodies.forEach(function (goodie) {
    console.log(this.nickname + ' любит: ' + goodie);
  });
}

const cat = {
  nickname: 'Кекс',
  greeting: 'Мяу',
  goodies: [
    'Свежую рыбку',
    'Шнурки хозяйских кроссовок',
  ],
  say,
};

cat.say(); 
// //Кекс говорит: Мяу.
// undefined любит: Свежую рыбку
// undefined любит: Шнурки хозяйских кроссовок

// Разберём нюанс, связанный с контекстом функций this.
//  Для его разбора возьмём пример из одноимённой главы.
// Напомним, что нам нужно выяснить, почему говорит «Мяу» Кекс, а любит вкусняшки undefined. 
// В коде программы оба значения мы получаем из контекста this.
// Проблема в том, что контекст определяется строго в момент вызова функции. Функцию say вызываем
//  мы сами на объекте cat. А кто вызывает колбэк метода forEach? Колбэк вызывает сам JavaScript.
function say () {
  console.log(this.nickname + ' говорит: ' + this.greeting + '.');

  const callback = (goodie) => {
    console.log(this.nickname + ' любит: ' + goodie);
  };

  this.goodies.forEach(callback);
}
// Чтобы программа работала, нам нужно как-то указать колбэку контекст исполнения. В таких случаях на помощь
//  спешит стрелочная функция, потому что её контекст закрепляется в момент объявления, а не вызова. И всё работает, как надо.